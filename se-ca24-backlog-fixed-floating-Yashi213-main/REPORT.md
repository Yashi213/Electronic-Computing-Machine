| Лабораторная работа №1 | M3104                  | АОВС |
| ---------------------- |------------------------| ---- |
| Представление чисел    | Пляк Яков Владимирович | 2024 |

> [!important]  
> Не забудьте указать в шапке свои ФИО и Номер группы

## Инструментарий
Язык: С++

Компилятор: MINGW64 gcc

Стандарт CXX20


## Вариант
Была выполнена полная версия, а именно все типы, со всеми округлениями.

## Результат работы на тестовых данных: https://github.com/skkv-itmo-comp-arch/se-comp-arch24-fixed-floating-Yashi213/actions/runs/8101444855



# Описание:

**Классы**

Использовалось 4 класса, а именно: 
1. Parsing - в данном кассе производилась обработка и изменение входных данных(командной строки).
2. CustomFloat - клас с реализацией чисел с фиксированной точкой
3. float16/float32 - классы с реализацией чисел с плавающей точкой (HalfPrecision/SinglePrecision соответственно)

Данное разбиение на классы связанно с количеством задач проекта.


**Хранение чисел**

1. CustomFloat(фиксированная точка) - для хранения данных чисел использовалось две переменные.  Uint32_t для целой части и Uint64_t
для десятичной. Uint64_t был выбран для того, чтобы не переполнять меньший тип данных при крайних случаях в умножении.
2. float16(HalfPrecision) - экспонента хранится в int8_t, так как в стандартных библиотеках нет возможности инициализировать переменную,
хранящую 5 бит. Для мантиссы используется Uint32_t для избежания переполнения при крайних случаях в умножении.
3. float32(SinglePrecision) -   всё идентично float 16, но типы данных ровно в два раза больше. Экспонента - int16_t, мантисса - Uint64_t

**nan/inf**

Данные крайние случаи обрабатываются в условиях и никак не преобразуются.  К примеру: если экспонента максимальная и мантисса не равна
0, то в стандартный поток выведется "nan". Крайние случаи обрабатывались перед каждой операцией, чтоб не делать лишних действий 
и не получить непонятный результат. Если нужно, например, сложить два числа, сначала проверяются некоторые условия, при выполнении
которых результат сразу известен (nan, inf, zero), после чего сразу производится выход из оператора.

**Округления**

Во всех 3 классах используется одинаковый принцип округления\
1. округление к 0 - просто отсеками ненужное количество бит (данное число передаётся методу).
2. округление к ближайшему чётному - сравниваем часть, которую нужно отсечь с числом, которое состоит из того же 
количества бит, что и отсекаемая часть и поделено на 2. Если отсекаемая часть больше данного числа, убираем эту часть и прибавляем 1
к результату, если меньше, единицу не прибавляем. В случае равенства, смотрим на последний бит перед отсекаемой частью. 
3. округление к +бесконечности - если отсекаемая часть не равна нулю и число положительное, отсекает нужное количество 
байтов и прибавляет единицу к результату, иначе просто убираем ненужные биты.
4. округление к -бесконечности - то же самое, что и +бесконечность, но число должно быть отрицательным. 

**Операции в CustomFloat**

Сложение - складываем два входных числа в десятичной системе счисления и округляем по уже известному алгоритму.

Вычитание - идентично сложению.

Умножение - умножаем два входных числа, сдвигаем на количество бит в десятичной части числа, так как при умножении количество 
знаков после запятой удваивается, и округляем.

Деление - сдвигаем делимое на количество бит после запятой, для того, чтобы поделить целочисленною на делитель. 
Потом округляем с небольшим нюансом, при округлении к ближайшему чётному, нужно сравнивать умноженный на 2 остаток с делителем.

**Операции float16/32**

Как уже было сказано, в начале любой операции производится проверка крайних случаев. Также после проверки производится нормализация числа.
В цикле побитово двигаем мантиссу влево, пока в старшем битье не появиться 1, параллельно уменьшаем экспоненту.

Числа готовы. Теперь каждая операция действует своим образом.

Сложение - разбираем случай, когда знаки слагаемых равны, иной случай приведёт к вычитанию. Для начала сравниваем разницу 
экспонент, если она больше допустимого, возвращаем число с мантиссой большего слагаемого (увеличиваем на 1 в зависимости от округления).
Далее находим сумму чисел, мантиссу большего числа сдвигаем влево на разницу экспонат и прибавляем вторую мантиссу. 
В случае если в найденной сумме появится "новый" бит, а именно бит перед старшим битом, увеличим экспоненту и при округлении
откинем на 1 бит больше.

Вычитание - похоже на сложение за исключением некоторых моментов. Для начала определяем наибольшее число по модулю, если 
наибольшим оказалось вычитаемое, то меняем знаки и вызываем оператор повторно. Далее те же условия, что и в сложении, при 
недопустимой разницы экспонент возвращаем наибольшую мантиссу (или мантисса - 1) со знаком наибольшего числа. Далее находим разность,
мантиссу наибольшего числа сдвигаем на разницу экспонент и вычитаем мантиссу второго числа. В случае, если из старшего бита мантиссы
пропал бит, возвращаем его с помощью цикла, побитового сдвига влево и декремента экспоненты. Округляем число.

Умножение - складываем экспоненты, умножаем мантиссы, в случае появления нового бита, увеличиваем экспоненту на 1 и при округлении 
откидываем на 1 бит больше.  

Деление - находим разницу экспонент, если полученная экспонента меньше минимальной, в цикле двигаем мантиссу влево и увеличиваем 
количество отсеиваемых битов. Затем сдвигаем делимую мантиссу влево на (10/23 или 11/23, если делимая мантисса меньше мантиссы делителя) 
и делим это число на сдвинутую мантиссу делителя. В округлении есть специфика, аналогичная CustomFloat(fixed).

После всех операций производим денормализацию результата(экспонента выходит за рамки)
  
Вывод - Проверяются все крайние случаи, определяется отрицательное ли число. Затем отделяется "невидимая" единица, 

Крайние случаи при всех операциях учтены согласно стандарту IEEE-74.
